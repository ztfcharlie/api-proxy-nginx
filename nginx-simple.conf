worker_processes  auto;
events {
    worker_connections 1024;
}

http {
    include       mime.types;
    default_type application/octet-stream;

    # 日志格式
    log_format main escape=json '{'
        '"time_local":"$time_local",'
        '"remote_addr":"$remote_addr",'
        '"request_method":"$request_method",'
        '"request_uri":"$request_uri",'
        '"status":"$status",'
        '"body_bytes_sent":"$body_bytes_sent",'
        '"request_time":"$request_time",'
        '"upstream_addr":"$upstream_addr",'
        '"upstream_status":"$upstream_status",'
        '"request_id":"$request_id",'
        '"api_key":"$api_key",'
        '"request_body":"$request_body",'
        '"response_body":"$response_body"'
    '}';

    sendfile        on;
    keepalive_timeout  65;

    # 代理服务器配置
    upstream gemini_api {
        server generativelanguage.googleapis.com:443;
        keepalive 32;
        keepalive_requests 100;
        keepalive_timeout 60s;
    }

    server {
        listen 8080;
        server_name _;

        # 基础认证
        auth_basic "Gemini API Proxy";
        auth_basic_user_file /etc/nginx/.htpasswd;

        # API Key替换
        set $target_api_key "";
        set $original_api_key "";

        location /v1beta/ {
            # 验证API Key
            if ($http_x_goog_api_key = "") {
                return 401 "API key required";
            }

            # 检查API Key是否在允许列表中
            if ($http_x_goog_api_key != "sk-valid-key-1" and
                $http_x_goog_api_key != "sk-valid-key-2" and
                $http_x_goog_api_key != "sk-valid-key-3") {
                return 403 "Invalid API key";
            }

            # 设置新的API Key
            set $target_api_key "AIzaSyDabcdefghijklmnopqrstuv1234567890abcdefghijklmnopqrstuvwxyz";
            set $original_api_key $http_x_goog_api_key;

            # 代理到Gemini API
            proxy_pass https://gemini_api;
            proxy_set_header x-goog-api-key $target_api_key;
            proxy_ssl_verify on;
            proxy_ssl_verify_depth 2;

            # 基础代理头
            proxy_set_header Host generativelanguage.googleapis.com;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_pass_request_headers on;
        }

        # 健康检查端点
        location /health {
            access_log off;
            return 200 "OK\n";
            add_header Content-Type text/plain;
        }

        # 状态端点
        location /status {
            access_log off;
            stub_status on;
        }
    }
}

# HTTPS支持（可选）
server {
    listen 8443 ssl;
    server_name _;

    # SSL证书配置
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    # 复用HTTP的location配置
    location /v1beta/ {
        # 验证API Key
        if ($http_x_goog_api_key = "") {
                return 401 "API key required";
            }

            # 检查API Key是否在允许列表中
            if ($http_x_goog_api_key != "sk-valid-key-1" and
                $http_x_goog_api_key != "sk-valid-key-2" and
                $http_x_goog_api_key != "sk-valid-key-3") {
                return 403 "Invalid API key";
            }

            # 设置新的API Key
            set $target_api_key "AIzaSyDabcdefghijklmnopqrstuv1234567890abcdefghijklmnopqrstuvwxyz";
            set $original_api_key $http_x_goog_api_key;

            # 代理到Gemini API
            proxy_pass https://gemini_api;
            proxy_set_header x-goog-api-key $target_api_key;
            proxy_ssl_verify on;
            proxy_ssl_verify_depth 2;

            # 基础代理头
            proxy_set_header Host generativelanguage.googleapis.com;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_pass_request_headers on;
        }

        # 健康检查端点
        location /health {
            access_log off;
            return 200 "OK\n";
            add_header Content-Type text/plain;
        }

        # 状态端点
        location /status {
            access_log off;
            stub_status on;
        }
    }