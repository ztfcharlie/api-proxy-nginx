# OAuth2 证书缓存配置
proxy_cache_path /var/cache/nginx/oauth2_certs levels=1:2 keys_zone=oauth2_certs:10m inactive=60m max_size=100m;

server {
    listen 8080;
    server_name _;

    # 强制读取请求体，以便 Lua 日志记录
    lua_need_request_body on;

    # 设置变量
    set $client_token "";
    set $key_filename "";
    set $model_name "";
    set $api_host "";
    set $my_request_id "";
    set $access_token "";
    # [Added] 动态协议变量，默认为 https
    set $upstream_scheme "https";

    # [Fix] 使用 Docker 内部 DNS (127.0.0.11) 以解析容器服务名 - 全局生效
    resolver 127.0.0.11 ipv6=off valid=30s;
    resolver_timeout 10s;

    # 主要 API 代理路径 (Vertex)
    location ~ ^/v1/projects/([^/]+)/locations/([^/]+)/publishers/google/models/([^/:]+):(.+)$ {
        # URL 重写阶段处理（预留给将来的功能扩展）
        rewrite_by_lua_block {
            if ngx.var.request_method == "OPTIONS" then
                ngx.header["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS"
                ngx.header["Access-Control-Allow-Headers"] = "Authorization, Content-Type"
                ngx.status = 200
                ngx.exit(200)
            end
        }

        # 访问阶段处理
        access_by_lua_block {
            local auth_manager = require "auth_manager"
            local stream_handler = require "stream_handler"
            local utils = require "utils"

            -- 生成请求ID
            ngx.var.my_request_id = utils.generate_request_id()

            -- 客户端认证和授权
            local client_token, access_token, metadata = auth_manager.authenticate_client()
            if not client_token then
                ngx.status = 401
                ngx.header.content_type = "application/json"
                ngx.say('{"error": "Unauthorized", "message": "Invalid client token"}')
                ngx.exit(401)
            end

            ngx.var.client_token = client_token
            ngx.var.access_token = access_token
            
            if metadata and metadata.channel_id then
                ngx.var.key_filename = tostring(metadata.channel_id)
            end

            local model_name = ngx.var[3]
            ngx.var.model_name = model_name

            local api_host = auth_manager.get_api_host(metadata, model_name)
            if not api_host then
                utils.error_response(400, "Upstream host resolution failed")
                return
            end

            ngx.var.api_host = api_host

            # [Added] Mock 模式协议切换
            if api_host == "api-proxy-nodejs:8889" then
                ngx.var.upstream_scheme = "http"
            end

            local is_streaming = stream_handler.detect_streaming_request()
            if is_streaming then
                ngx.ctx.is_streaming = true
            end

            ngx.req.clear_header("Authorization")
            ngx.req.set_header("Authorization", "Bearer " .. access_token)

            utils.remove_privacy_headers()
            ngx.req.set_header("Host", api_host)
        }

        # 代理到 Google API (或 Mock 服务)
        proxy_pass $upstream_scheme://$api_host;

        # 隐私保护：显式清空 IP 相关头部
        proxy_set_header X-Forwarded-For "";
        proxy_set_header X-Real-IP "";
        proxy_set_header Client-IP "";
        proxy_set_header X-Client-IP "";
        proxy_set_header Via "";

        # SSL 设置 - 启用证书验证
        proxy_ssl_verify on;
        proxy_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
        proxy_ssl_verify_depth 2;
        proxy_ssl_server_name on;
        proxy_ssl_name $api_host;
        proxy_ssl_protocols TLSv1.2 TLSv1.3;
        proxy_ssl_ciphers ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS;

        # 网络设置
        resolver 8.8.8.8 8.8.4.4 ipv6=off valid=300s;
        resolver_timeout 10s;

        # 代理头部设置
        proxy_set_header Host $api_host;
        proxy_set_header Accept-Encoding "";
        proxy_pass_request_headers on;

        # 流式请求支持
        proxy_request_buffering off;
        proxy_buffering off;
        proxy_cache off;
        chunked_transfer_encoding on;
        proxy_max_temp_file_size 0;
        gzip off;

        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        proxy_http_version 1.1;
        proxy_set_header Connection "keep-alive";

        # 响应处理
        header_filter_by_lua_block {
            local utils = require "utils"
            local stream_handler = require "stream_handler"
            utils.clean_response_headers()
            if ngx.ctx.is_streaming then
                stream_handler.set_streaming_headers()
            end
        }

        body_filter_by_lua_block {
            local stream_handler = require "stream_handler"
            if ngx.ctx.is_streaming then
                stream_handler.handle_streaming_response()
            end
        }

        # 日志记录
        log_by_lua_block {
            local utils = require "utils"
            utils.log_request()
        }
    }

    # 通用 API 代理路径 (OpenAI/DeepSeek/Anthropic/Azure)
    # 匹配 /v1/chat/completions 等标准接口
    location ~ ^/v1/(.+)$ {
        # 访问阶段处理
        access_by_lua_block {
            local auth_manager = require "auth_manager"
            local stream_handler = require "stream_handler"
            local utils = require "utils"

            -- 生成请求ID
            ngx.var.my_request_id = utils.generate_request_id()

            -- 客户端认证和授权
            local client_token, access_token, metadata = auth_manager.authenticate_client()
            if not client_token then
                ngx.status = 401
                ngx.header.content_type = "application/json"
                ngx.say('{"error": "Unauthorized", "message": "Invalid client token"}')
                ngx.exit(401)
            end

            ngx.var.client_token = client_token
            ngx.var.access_token = access_token
            
            if metadata and metadata.channel_id then
                ngx.var.key_filename = tostring(metadata.channel_id)
            end

            -- 尝试从 URL 中提取模型名称 (如果符合 OpenAI 格式)
            -- 这里不做强校验，因为 get_api_host 主要依赖 channel_type
            -- 如果需要模型名来做 Region 路由 (Vertex)，前面那个 location 已经匹配了
            -- 这里主要是为了非 Vertex，但也可能匹配到 Vertex 的其他接口
            
            -- 获取 API 主机
            -- 注意：对于非 Vertex，model_name 可能不重要，传 nil 也可以，或者尝试从 body 解析（太复杂）
            -- 简单起见，我们传 nil，get_api_host 会处理通用逻辑
            local api_host = auth_manager.get_api_host(metadata, nil)
            
            if not api_host then
                utils.error_response(400, "Upstream host resolution failed")
                return
            end

            ngx.var.api_host = api_host

            # [Added] Mock 模式协议切换
            if api_host == "api-proxy-nodejs:8889" then
                ngx.var.upstream_scheme = "http"
            end

            -- 检测是否为流式请求
            local is_streaming = stream_handler.detect_streaming_request()
            if is_streaming then
                ngx.ctx.is_streaming = true
            end

            -- 移除客户端的 Authorization 头部
            ngx.req.clear_header("Authorization")
            
            -- 设置 Upstream 鉴权头
            -- OpenAI/DeepSeek 通常用 Authorization: Bearer sk-...
            -- Azure 用 api-key 头
            if metadata.channel_type == "azure" then
                ngx.req.set_header("api-key", access_token)
            else
                ngx.req.set_header("Authorization", "Bearer " .. access_token)
            end

            -- 移除隐私相关头部
            utils.remove_privacy_headers()

            -- 设置目标主机头部
            ngx.req.set_header("Host", api_host)
        }

        # 代理到 Google API
        proxy_pass $upstream_scheme://$api_host;

        # 隐私保护：显式清空 IP 相关头部，防止 Nginx 自动添加
        proxy_set_header X-Forwarded-For "";
        proxy_set_header X-Real-IP "";
        proxy_set_header Client-IP "";
        proxy_set_header X-Client-IP "";
        proxy_set_header Via "";

        # SSL 设置 - 启用证书验证
        proxy_ssl_verify on;  # 修改：启用 SSL 验证
        proxy_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;  # 添加：指定 CA 证书文件
        proxy_ssl_verify_depth 2;  # 添加：设置验证深度
        proxy_ssl_server_name on;
        proxy_ssl_name $api_host;
        proxy_ssl_protocols TLSv1.2 TLSv1.3;
        proxy_ssl_ciphers ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS;

        # 网络设置 - 禁用IPv6，只使用IPv4
        # resolver 指令已移至 server 块全局配置

        # 代理头部设置
        proxy_set_header Host $api_host;
        proxy_set_header Accept-Encoding ""; # 禁用上游压缩，确保Lua能处理响应体
        proxy_pass_request_headers on;

        # 流式支持
        proxy_request_buffering off;
        proxy_buffering off;
        proxy_cache off;
        chunked_transfer_encoding on;
        proxy_max_temp_file_size 0;
        gzip off;

        # 超时
        proxy_connect_timeout 60s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        proxy_http_version 1.1;
        proxy_set_header Connection "keep-alive";

        # 响应处理
        header_filter_by_lua_block {
            local utils = require "utils"
            local stream_handler = require "stream_handler"
            utils.clean_response_headers()
            if ngx.ctx.is_streaming then
                stream_handler.set_streaming_headers()
            end
        }

        body_filter_by_lua_block {
            local stream_handler = require "stream_handler"
            if ngx.ctx.is_streaming then
                stream_handler.handle_streaming_response()
            end
        }

        log_by_lua_block {
            local utils = require "utils"
            utils.log_request()
        }
    }
    
    # OAuth2 模拟服务路由
    # 本地OAuth2模拟服务，用于在测试/开发环境中避免连接真实Google服务

    # OAuth2 授权码端点
    location /accounts.google.com/o/oauth2/auth {
        proxy_pass http://api-proxy-nodejs:8889/accounts.google.com/o/oauth2/auth;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header X-Original-Method $request_method;

        # CORS 支持
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, X-Requested-With";
        add_header Access-Control-Allow-Credentials true;

        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type 'text/plain; charset=utf-8';
            add_header Content-Length 0;
            return 204;
        }
    }

    # OAuth2 令牌端点（模拟 Google OAuth2 API）
    location /oauth2.googleapis.com/token {
        proxy_pass http://api-proxy-nodejs:8889/accounts.google.com/oauth2/token;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header X-Original-Method $request_method;

        # CORS 支持
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods "POST, OPTIONS";
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, X-Requested-With";
        add_header Access-Control-Allow-Credentials true;

        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type 'text/plain; charset=utf-8';
            add_header Content-Length 0;
            return 204;
        }
    }

    # OAuth2 证书端点
    location /www.googleapis.com/oauth2/v1/certs {
        proxy_pass http://api-proxy-nodejs:8889/accounts.google.com/oauth2/v1/certs;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # 缓存设置
        proxy_cache oauth2_certs;
        proxy_cache_valid 200 1h;
        proxy_cache_key $scheme$proxy_host$request_uri;
        add_header X-Cache-Status $upstream_cache_status;

        # CORS 支持
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods "GET, OPTIONS";
        add_header Access-Control-Allow-Headers "X-Requested-With";
    }

    # 服务账号证书端点
    location ~ ^/www.googleapis.com/robot/v1/metadata/x509/(.*)$ {
        proxy_pass http://api-proxy-nodejs:8889/accounts.google.com/robot/v1/metadata/x509/$1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # 缓存设置
        proxy_cache oauth2_certs;
        proxy_cache_valid 200 1h;
        proxy_cache_key $scheme$proxy_host$request_uri;
        add_header X-Cache-Status $upstream_cache_status;

        # CORS 支持
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods "GET, OPTIONS";
        add_header Access-Control-Allow-Headers "X-Requested-With";
    }

    # 其余配置保持不变...
    # 隐私测试端点
    location /test-privacy {
        access_by_lua_block {
            local utils = require "utils"
            -- 移除隐私相关头部
            utils.remove_privacy_headers()
        }

        # 隐私保护：显式清空 IP 相关头部
        proxy_set_header X-Forwarded-For "";
        proxy_set_header X-Real-IP "";
        proxy_set_header Client-IP "";
        proxy_set_header X-Client-IP "";
        proxy_set_header Via "";

        # 代理头部设置
        proxy_set_header Host "test-privacy-backend";
        proxy_pass_request_headers on;

                # 代理到 Node.js 后端服务 (API Endpoint)
                proxy_pass http://api-proxy-nodejs:8889/api/privacy/check;
            }
        
            # 管理后台界面
    # 健康检查端点
    location /health {
        access_log off;
        content_by_lua_block {
            local cjson = require "cjson"
            ngx.header.content_type = "application/json"
            ngx.say(cjson.encode({
                status = "ok",
                timestamp = ngx.time(),
                version = "1.0.0"
            }))
        }
    }

    # 状态端点
    location /status {
        access_log off;
        content_by_lua_block {
            local cjson = require "cjson"
            local config = require "config"

            ngx.header.content_type = "application/json"
            ngx.say(cjson.encode({
                status = "running",
                config_loaded = config.is_loaded(),
                timestamp = ngx.time()
            }))
        }
    }


    # [Security] 显式禁止外部直接访问 /admin (防止通过兜底路由绕过混淆)
    location ^~ /admin/ {
        return 404;
    }

    # 管理后台界面 (路径混淆)
    location /ops-console/ {
        # [Fix] 根路径强制指向 console.html，避免加载前台 index.html
        rewrite ^/ops-console/?$ /admin/console.html break;
        
        # 1. 路径重写 (保持现状，这是最稳健的方式)
        rewrite ^/ops-console/(.*) /admin/$1 break;
        proxy_pass http://api-proxy-nodejs:8889;
        
        # 2. 基本代理头部
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # 3. [Added] WebSocket 支持 (管理后台实时日志通常需要)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # 4. [Optimized] 重定向替换 (正则匹配所有情况)
        # 拦截相对路径
        proxy_redirect /admin/ /ops-console/;
        # 拦截绝对路径 (正则: http或https + 任意主机名/IP + /admin/)
        proxy_redirect ~^https?://[^/]+/admin/(.*)$ /ops-console/$1;
    }

    # 错误页面
    error_page 400 /error/400.json;
    error_page 401 /error/401.json;
    error_page 403 /error/403.json;
    error_page 429 /error/429.json;
    error_page 500 502 503 504 /error/50x.json;

    location ~ ^/error/(\d+)\.json$ {
        internal;
        content_by_lua_block {
            local cjson = require "cjson"
            local status = ngx.var[1]
            local messages = {
                ["400"] = "Bad Request",
                ["401"] = "Unauthorized",
                ["403"] = "Forbidden",
                ["429"] = "Too Many Requests",
                ["50x"] = "Internal Server Error"
            }

            ngx.header.content_type = "application/json"
            ngx.status = tonumber(status) or 500
            ngx.say(cjson.encode({
                error = messages[status] or messages["50x"],
                status = tonumber(status) or 500,
                timestamp = ngx.time()
            }))
        }
    }

    # [Restored] 通用兜底代理 (处理 /api/ 等未匹配路径)
    location / {
        proxy_pass http://api-proxy-nodejs:8889;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # 支持 WebSocket (如果需要)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
