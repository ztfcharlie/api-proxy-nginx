server {
    listen 8080;
    server_name _;

    # 设置变量
    set $client_token "";
    set $key_filename "";
    set $model_name "";
    set $api_host "";
    set $my_request_id "";
    set $access_token "";

    # 主要 API 代理路径
    location ~ ^/v1/projects/([^/]+)/locations/([^/]+)/publishers/google/models/([^/:]+):(.+)$ {
        # URL 重写阶段处理（预留给将来的功能扩展）
        rewrite_by_lua_block {
            -- 当前不进行任何 URL 重写处理
            -- 预留给将来可能的功能：
            -- 1. URL 参数标准化
            -- 2. 路径重写和重定向
            -- 3. 请求路由规则定制
            -- 4. API 版本转换

            if ngx.var.request_method == "OPTIONS" then
                -- 可以在这里处理 CORS 预检请求
                -- ngx.header["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS"
                -- ngx.header["Access-Control-Allow-Headers"] = "Authorization, Content-Type"
                -- ngx.status = 200
                -- ngx.exit(200)
            end

            -- TODO: 将来可以在这里添加更多 URL 处理逻辑
        }

        # 访问阶段处理
        access_by_lua_block {
            local auth_manager = require "auth_manager"
            local stream_handler = require "stream_handler"
            local utils = require "utils"

            -- 生成请求ID
            ngx.var.my_request_id = utils.generate_request_id()

            -- 客户端认证和授权（返回 client_token, access_token, key_filename）
            local client_token, access_token, key_filename = auth_manager.authenticate_client()
            if not client_token then
                return -- 认证失败，已返回错误响应
            end

            ngx.var.client_token = client_token
            ngx.var.access_token = access_token
            ngx.var.key_filename = key_filename

            -- 提取模型名称
            local model_name = ngx.var[3] -- 从正则表达式捕获组获取
            ngx.var.model_name = model_name

            -- 获取 API 主机（使用 key_filename 和 model_name）
            local api_host = auth_manager.get_api_host(key_filename, model_name)
            if not api_host then
                utils.error_response(400, "Model not supported: " .. model_name)
                return
            end

            ngx.var.api_host = api_host

            -- 检测是否为流式请求
            local is_streaming = stream_handler.detect_streaming_request()
            if is_streaming then
                ngx.ctx.is_streaming = true
            end

            -- 移除客户端的 Authorization 头部
            ngx.req.clear_header("Authorization")
            -- 设置 OAuth2 Access Token
            ngx.req.set_header("Authorization", "Bearer " .. access_token)

            -- 移除隐私相关头部
            utils.remove_privacy_headers()

            -- 设置目标主机头部
            ngx.req.set_header("Host", api_host)
        }

        # 代理到 Google API
        proxy_pass https://$api_host;

        # SSL 设置 - 启用证书验证
        proxy_ssl_verify on;  # 修改：启用 SSL 验证
        proxy_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;  # 添加：指定 CA 证书文件
        proxy_ssl_verify_depth 2;  # 添加：设置验证深度
        proxy_ssl_server_name on;
        proxy_ssl_name $api_host;
        proxy_ssl_protocols TLSv1.2 TLSv1.3;
        proxy_ssl_ciphers ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS;

        # 网络设置 - 禁用IPv6，只使用IPv4
        resolver 8.8.8.8 8.8.4.4 ipv6=off valid=300s;
        resolver_timeout 10s;

        # 代理头部设置
        proxy_set_header Host $api_host;
        proxy_set_header Accept-Encoding ""; # 禁用上游压缩，确保Lua能处理响应体
        proxy_pass_request_headers on;

        # 流式请求支持
        proxy_request_buffering off;
        proxy_buffering off;
        proxy_cache off;

        # 禁用 nginx 内部缓冲，确保实时转发
        chunked_transfer_encoding on;

        # 确保不会因为缓冲而延迟响应
        proxy_max_temp_file_size 0;

        # 禁用gzip压缩，避免影响流式响应
        gzip off;

        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;

        # 保持连接
        proxy_http_version 1.1;
        proxy_set_header Connection "keep-alive";

        # 响应处理
        header_filter_by_lua_block {
            local utils = require "utils"
            local stream_handler = require "stream_handler"

            -- 移除可能泄露信息的响应头部
            utils.clean_response_headers()

            -- 如果是流式请求，设置流式响应头部
            if ngx.ctx.is_streaming then
                stream_handler.set_streaming_headers()
            end
        }

        # 响应体处理（用于流式请求）
        body_filter_by_lua_block {
            local stream_handler = require "stream_handler"
            if ngx.ctx.is_streaming then
                stream_handler.handle_streaming_response()
            end
        }

        # 日志记录
        log_by_lua_block {
            local utils = require "utils"
            utils.log_request()
        }
    }
    

    # 新增：操作状态查询路径
    location ~ ^/v1/projects/([^/]+)/locations/([^/]+)/publishers/google/models/([^/]+)/operations/([^/]+)$ {
        # 访问阶段处理
        access_by_lua_block {
            local auth_manager = require "auth_manager"
            local utils = require "utils"

            -- 生成请求ID
            ngx.var.my_request_id = utils.generate_request_id()

            -- 客户端认证和授权
            local client_token, access_token, key_filename = auth_manager.authenticate_client()
            if not client_token then
                return -- 认证失败，已返回错误响应
            end

            ngx.var.client_token = client_token
            ngx.var.access_token = access_token
            ngx.var.key_filename = key_filename

            -- 提取模型名称
            local model_name = ngx.var[3] -- 从正则表达式捕获组获取
            ngx.var.model_name = model_name

            -- 获取 API 主机
            local api_host = auth_manager.get_api_host(key_filename, model_name)
            if not api_host then
                utils.error_response(400, "Model not supported: " .. model_name)
                return
            end

            ngx.var.api_host = api_host

            -- 移除客户端的 Authorization 头部
            ngx.req.clear_header("Authorization")
            -- 设置 OAuth2 Access Token
            ngx.req.set_header("Authorization", "Bearer " .. access_token)

            -- 移除隐私相关头部
            utils.remove_privacy_headers()

            -- 设置目标主机头部
            ngx.req.set_header("Host", api_host)
        }

        # 代理到 Google API
        proxy_pass https://$api_host;

        # SSL 设置
        proxy_ssl_verify on;
        proxy_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
        proxy_ssl_verify_depth 2;
        proxy_ssl_server_name on;
        proxy_ssl_name $api_host;
        proxy_ssl_protocols TLSv1.2 TLSv1.3;
        proxy_ssl_ciphers ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS;

        # 网络设置
        resolver 8.8.8.8 8.8.4.4 ipv6=off valid=300s;
        resolver_timeout 10s;

        # 代理头部设置
        proxy_set_header Host $api_host;
        proxy_pass_request_headers on;

        # 超时设置 - 操作查询可能需要更长时间
        proxy_connect_timeout 60s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;

        # 保持连接
        proxy_http_version 1.1;
        proxy_set_header Connection "";

        # 响应处理
        header_filter_by_lua_block {
            local utils = require "utils"
            -- 移除可能泄露信息的响应头部
            utils.clean_response_headers()
        }

        # 日志记录
        log_by_lua_block {
            local utils = require "utils"
            utils.log_request()
        }
    }

    # 其余配置保持不变...
    # 健康检查端点
    location /health {
        access_log off;
        content_by_lua_block {
            local cjson = require "cjson"
            ngx.header.content_type = "application/json"
            ngx.say(cjson.encode({
                status = "ok",
                timestamp = ngx.time(),
                version = "1.0.0"
            }))
        }
    }

    # 状态端点
    location /status {
        access_log off;
        content_by_lua_block {
            local cjson = require "cjson"
            local config = require "config"

            ngx.header.content_type = "application/json"
            ngx.say(cjson.encode({
                status = "running",
                config_loaded = config.is_loaded(),
                timestamp = ngx.time()
            }))
        }
    }

    # 错误页面
    error_page 400 /error/400.json;
    error_page 401 /error/401.json;
    error_page 403 /error/403.json;
    error_page 429 /error/429.json;
    error_page 500 502 503 504 /error/50x.json;

    location ~ ^/error/(\d+)\.json$ {
        internal;
        content_by_lua_block {
            local cjson = require "cjson"
            local status = ngx.var[1]
            local messages = {
                ["400"] = "Bad Request",
                ["401"] = "Unauthorized",
                ["403"] = "Forbidden",
                ["429"] = "Too Many Requests",
                ["50x"] = "Internal Server Error"
            }

            ngx.header.content_type = "application/json"
            ngx.status = tonumber(status) or 500
            ngx.say(cjson.encode({
                error = messages[status] or messages["50x"],
                status = tonumber(status) or 500,
                timestamp = ngx.time()
            }))
        }
    }
}
