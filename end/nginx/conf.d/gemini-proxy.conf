server {
    listen 8080;
    server_name _;

    # 设置变量
    set $client_id "";
    set $model_name "";
    set $api_host "";
    set $my_request_id "";
    set $google_token "";

    # 主要 API 代理路径
    location ~ ^/v1/projects/([^/]+)/locations/([^/]+)/publishers/google/models/([^/:]+):(.+)$ {
        # URL 重写阶段处理（预留给将来的功能扩展）
        rewrite_by_lua_block {
            -- 当前不进行任何 URL 重写处理
            -- 预留给将来可能的功能：
            -- 1. URL 参数标准化
            -- 2. 路径重写和重定向
            -- 3. 请求路由规则定制
            -- 4. API 版本转换

            if ngx.var.request_method == "OPTIONS" then
                -- 可以在这里处理 CORS 预检请求
                -- ngx.header["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS"
                -- ngx.header["Access-Control-Allow-Headers"] = "Authorization, Content-Type"
                -- ngx.status = 200
                -- ngx.exit(200)
            end

            -- TODO: 将来可以在这里添加更多 URL 处理逻辑
        }

        # 访问阶段处理
        access_by_lua_block {
            local auth_manager = require "auth_manager"
            local stream_handler = require "stream_handler"
            local utils = require "utils"

            -- 生成请求ID
            ngx.var.my_request_id = utils.generate_request_id()

            -- 客户端认证和授权
            local client_id, google_token = auth_manager.authenticate_client()
            if not client_id then
                return -- 认证失败，已返回错误响应
            end

            ngx.var.client_id = client_id
            ngx.var.google_token = google_token

            -- 提取模型名称
            local model_name = ngx.var[3] -- 从正则表达式捕获组获取
            ngx.var.model_name = model_name

            -- 获取 API 主机
            local api_host = auth_manager.get_api_host(client_id, model_name)
            if not api_host then
                utils.error_response(400, "Model not supported for this client")
                return
            end

            ngx.var.api_host = api_host

            -- 检测是否为流式请求
            local is_streaming = stream_handler.detect_streaming_request()
            if is_streaming then
                ngx.ctx.is_streaming = true
            end

            -- 移除客户端的 Authorization 头部
            ngx.req.clear_header("Authorization")
            -- 设置 Google OAuth2 Token
            ngx.req.set_header("Authorization", "Bearer " .. google_token)

            -- 移除隐私相关头部
            utils.remove_privacy_headers()

            -- 设置目标主机头部
            ngx.req.set_header("Host", api_host)
        }

        # 代理到 Google API
        proxy_pass https://$api_host;

        # SSL 设置
        proxy_ssl_verify on;
        proxy_ssl_verify_depth 2;
        proxy_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;

        # 代理头部设置
        proxy_set_header Host $api_host;
        proxy_pass_request_headers on;

        # 流式请求支持
        proxy_request_buffering off;
        proxy_buffering off;
        proxy_cache off;

        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;

        # 保持连接
        proxy_http_version 1.1;
        proxy_set_header Connection "";

        # 响应处理
        header_filter_by_lua_block {
            local utils = require "utils"
            -- 移除可能泄露信息的响应头部
            utils.clean_response_headers()
        }

        # 响应体处理（用于流式请求）
        body_filter_by_lua_block {
            local stream_handler = require "stream_handler"
            if ngx.ctx.is_streaming then
                stream_handler.handle_streaming_response()
            end
        }

        # 日志记录
        log_by_lua_block {
            local utils = require "utils"
            utils.log_request()
        }
    }

    # 健康检查端点
    location /health {
        access_log off;
        content_by_lua_block {
            local cjson = require "cjson"
            ngx.header.content_type = "application/json"
            ngx.say(cjson.encode({
                status = "ok",
                timestamp = ngx.time(),
                version = "1.0.0"
            }))
        }
    }

    # 状态端点
    location /status {
        access_log off;
        content_by_lua_block {
            local cjson = require "cjson"
            local config = require "config"

            ngx.header.content_type = "application/json"
            ngx.say(cjson.encode({
                status = "running",
                config_loaded = config.is_loaded(),
                timestamp = ngx.time()
            }))
        }
    }

    # 错误页面
    error_page 400 /error/400.json;
    error_page 401 /error/401.json;
    error_page 403 /error/403.json;
    error_page 429 /error/429.json;
    error_page 500 502 503 504 /error/50x.json;

    location ~ ^/error/(\d+)\.json$ {
        internal;
        content_by_lua_block {
            local cjson = require "cjson"
            local status = ngx.var[1]
            local messages = {
                ["400"] = "Bad Request",
                ["401"] = "Unauthorized",
                ["403"] = "Forbidden",
                ["429"] = "Too Many Requests",
                ["50x"] = "Internal Server Error"
            }

            ngx.header.content_type = "application/json"
            ngx.status = tonumber(status) or 500
            ngx.say(cjson.encode({
                error = messages[status] or messages["50x"],
                status = tonumber(status) or 500,
                timestamp = ngx.time()
            }))
        }
    }
}