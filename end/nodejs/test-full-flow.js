const axios = require('axios');
const jwt = require('jsonwebtoken');
const fs = require('fs');
const path = require('path');

// 配置
const ADMIN_API = 'http://localhost:8888/api/admin';
const PROXY_BASE = 'http://localhost:8888';

// 颜色输出
const colors = {
    green: '\x1b[32m',
    red: '\x1b[31m',
    yellow: '\x1b[33m',
    reset: '\x1b[0m'
};
const log = (msg, color = colors.reset) => console.log(`${color}[TEST] ${msg}${colors.reset}`);

async function runTest() {
    try {
        log("Starting End-to-End Test...", colors.yellow);

        // ---------------------------------------------------------
        // Step 1: 创建用户
        // ---------------------------------------------------------
        const username = `test_user_${Date.now()}`;
        log(`1. Creating user: ${username}...`);
        await axios.post(`${ADMIN_API}/users`, {
            username: username,
            password: 'password123',
            remark: 'Auto-generated by test script'
        });
        
        // 获取用户ID
        const usersRes = await axios.get(`${ADMIN_API}/users`);
        const user = usersRes.data.data.find(u => u.username === username);
        if (!user) throw new Error("User creation failed");
        log(`   User created with ID: ${user.id}`, colors.green);


        // ---------------------------------------------------------
        // Step 2: 创建 Vertex 渠道
        // ---------------------------------------------------------
        log(`2. Creating Vertex Channel...`);
        // 这是一个假的 Service Account，仅用于测试流程
        const fakeVertexCreds = {
            "type": "service_account",
            "project_id": "real-google-project",
            "private_key_id": "123456",
            "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC...\n-----END PRIVATE KEY-----\n", // 简化的key
            "client_email": "real-service-account@google.com",
            "client_id": "123",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
        };
        
        const vertexChannelRes = await axios.post(`${ADMIN_API}/channels`, {
            name: `Vertex_Channel_${Date.now()}`,
            type: 'vertex',
            credentials: JSON.stringify(fakeVertexCreds),
            extra_config: {},
            models_config: {}
        });
        const vertexChannelId = vertexChannelRes.data.id;
        log(`   Vertex Channel created with ID: ${vertexChannelId}`, colors.green);


        // ---------------------------------------------------------
        // Step 3: 创建 Vertex Virtual Token
        // ---------------------------------------------------------
        log(`3. Creating Virtual Token (Vertex)...`);
        const vTokenRes = await axios.post(`${ADMIN_API}/tokens`, {
            user_id: user.id,
            name: 'My Vertex Token',
            type: 'vertex',
            routes: [{ channel_id: vertexChannelId, weight: 100 }]
        });
        
        const vTokenCreds = vTokenRes.data.credentials; // 这是生成的 JSON
        log(`   Virtual Token created. Mock Client Email: ${vTokenCreds.client_email}`, colors.green);
        
        
        // ---------------------------------------------------------
        // Step 4: 客户端模拟 - Vertex OAuth2 交换
        // ---------------------------------------------------------
        log(`4. Simulating Client OAuth2 Exchange...`);
        
        // 4.1 签发 JWT
        const now = Math.floor(Date.now() / 1000);
        const payload = {
            iss: vTokenCreds.client_email,
            sub: vTokenCreds.client_email,
            aud: vTokenCreds.token_uri,
            iat: now,
            exp: now + 3600,
            scope: 'https://www.googleapis.com/auth/cloud-platform'
        };
        
        const signedJwt = jwt.sign(payload, vTokenCreds.private_key, { algorithm: 'RS256', keyid: vTokenCreds.private_key_id });
        log(`   JWT Signed successfully.`);

        // 4.2 请求 /oauth2/token
        // 注意：我们请求的是 Nginx 代理的地址 (https://localhost:8888/...)
        // 但这里为了防止 SSL 报错，我们先用 http://localhost:8888/accounts.google.com/oauth2/token
        // Nginx 配置中 location 是 /accounts.google.com
        try {
            const tokenUrl = `${PROXY_BASE}/accounts.google.com/oauth2/token`;
            log(`   POST ${tokenUrl}...`);
            
            const oauthRes = await axios.post(tokenUrl, {
                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                assertion: signedJwt
            });
            
            const accessToken = oauthRes.data.access_token;
            log(`   Success! Received Virtual Access Token: ${accessToken.substring(0, 15)}...`, colors.green);
            
            // 4.3 (可选) 验证 Nginx/Lua 转发
            // 我们用这个 Access Token 访问一个假的 API，看 Lua 是否拦截
            // 预期结果：503 (因为真实渠道的 Key 是假的，Node.js 无法获取 Real Token)
            // 或者如果 Node.js Mock 逻辑里对 Real Token 获取做了 Try-Catch 并允许返回空，Lua 会报 503
            
            log(`   (Verify) Access Token received successfully. This proves Node.js Mock & Redis logic is working.`);

        } catch (err) {
            if (err.response) {
                 // 503 是预期的，因为我们的真实 Google Key 是假的，后台刷新任务肯定失败了
                 if (err.response.status === 503) {
                     log(`   Got 503 as expected (Upstream token unavailable). The flow is correct!`, colors.green);
                 } else {
                     log(`   Failed with status ${err.response.status}: ${JSON.stringify(err.response.data)}`, colors.red);
                 }
            } else {
                log(`   Network Error: ${err.message}`, colors.red);
            }
        }


        // ---------------------------------------------------------
        // Step 5: 创建 Azure Channel & Token (API Key Mode)
        // ---------------------------------------------------------
        log(`5. Testing Azure/OpenAI Mode...`);
        
        const azureChannelRes = await axios.post(`${ADMIN_API}/channels`, {
            name: `Azure_Channel_${Date.now()}`,
            type: 'azure',
            credentials: 'real-azure-sk-key', // 假的
            extra_config: { endpoint: 'https://my-azure.openai.azure.com' }
        });
        
        const aTokenRes = await axios.post(`${ADMIN_API}/tokens`, {
            user_id: user.id,
            name: 'My Azure Token',
            type: 'azure',
            routes: [{ channel_id: azureChannelRes.data.id, weight: 100 }]
        });
        
        const virtualApiKey = aTokenRes.data.credentials.api_key;
        log(`   Generated Virtual API Key: ${virtualApiKey}`, colors.green);
        
        // 验证 Lua 是否能识别这个 Key
        // 我们发送一个请求到 Nginx，带上 api-key 头
        // Nginx 应该查 Redis -> 找到 real key -> 转发 -> 失败 (因为 endpoint 是假的)
        try {
            // Azure 风格请求
            await axios.post(`${PROXY_BASE}/openai/deployments/gpt-4/chat/completions?api-version=2023-05-15`, {}, {
                headers: { 'api-key': virtualApiKey }
            });
        } catch (err) {
            // 我们期望的是 Nginx 尝试连接 https://my-azure.openai.azure.com 然后超时或 DNS 错误，或者返回 502
            // 或者如果是 DNS 解析失败，Nginx 会返回 502 Bad Gateway
            if (err.response && (err.response.status === 502 || err.response.status === 504)) {
                log(`   Got ${err.response.status} from Nginx. This means Nginx TRIED to forward request to the fake endpoint. Success!`, colors.green);
            } else {
                // 如果是 401/403，说明 Lua 没认出 Key
                 if (err.response && err.response.status === 401) {
                     log(`   Got 401 Unauthorized. Lua did not recognize the key from Redis!`, colors.red);
                 } else {
                     log(`   Got unexpected error: ${err.message}`, colors.yellow);
                 }
            }
        }

        log("\nTest Completed.", colors.green);

    } catch (error) {
        console.error(error);
        log(`Test Failed: ${error.message}`, colors.red);
    }
}

runTest();
